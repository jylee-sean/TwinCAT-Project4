///////////////////////////////////////////////////////////////////////////////
// Module1.h
#pragma once

#include "Untitled1Interfaces.h"
#include "AdsR0.h"
#include <vector>

//#include "Motor.h"
//#include <vector>


#define CALL_MEMBER_FN(object, ptrToMember) ((object).*(ptrToMember))
// parameter ids for TwinCAT module Module1 with disabled code generation
// could be moved to Untitled1Services.h
const PTCID PID_Module1AdsPort        = 0x00000002;








class CModule1 
	: public ITComObject
	, public ITcADI
	, public ITcWatchSource
///<AutoGeneratedContent id="InheritanceList">
	, public ITcCyclic
///</AutoGeneratedContent>
	, public CAdsR0FifoPort
	, public Motor

{
public:
	DECLARE_IUNKNOWN()
DECLARE_IPERSIST(CID_Untitled1CModule1)
DECLARE_ITCOMOBJECT_LOCKOP()
DECLARE_ITCADI()
DECLARE_ITCWATCHSOURCE()
DECLARE_OBJPARAWATCH_MAP()
DECLARE_OBJDATAAREA_MAP()



CModule1();
virtual	~CModule1();




///<AutoGeneratedContent id="InterfaceMembers">
	// ITcCyclic
virtual HRESULT TCOMAPI CycleUpdate(ITcTask* ipTask, ITcUnknown* ipCaller, ULONG_PTR context);

///</AutoGeneratedContent>

	// CAds
virtual	void	AdsReadWriteInd
(
	AmsAddr& rAddr,
	ULONG invokeId,
	ULONG indexGroup,
	ULONG indexOffset,
	ULONG cbReadLength,
	ULONG cbWriteLength,
	PVOID pData
);

virtual void AdsReadCon
(
	AmsAddr& rAddr,
	ULONG invokeId,
	ULONG result,
	ULONG cbLength,
	PVOID pData
);

enum RESULT {success = true, fail = false};

public:

protected:
	DECLARE_ITCOMOBJECT_SETSTATE();

	HRESULT AddModuleToCaller();
	VOID RemoveModuleFromCaller();
	
	// Tracing
	CTcTrace m_Trace;

	///<AutoGeneratedContent id="Members">
	TcTraceLevel m_TraceLevelMax;
	WORD m_DefaultAdsPort;
	WORD m_ContextAdsPort;
	ULONG m_Counter;
	SHORT m_move;
	LONG m_target;
	Module1Inputs m_Inputs;
	Module1Outputs m_Outputs;
	Module1DataArea3 m_DataArea3;

	ITcCyclicCallerInfoPtr m_spCyclicCaller;
	

	///</AutoGeneratedContent>

	void SubmitAdsReadReq();
	enum
	{
		invokeIdReadByOidAndPid = 1
	};
	ULONG  m_ReadByOidAndPid;
	
	std::vector<Motor> motors; 
	static constexpr INT timeout_cnt =1000;
	fp* execute;

private:

	fp servo_on[6] = { &CModule1::set_disable_voltage ,&CModule1::set_shutdown, &CModule1::set_ready_to_switch_on, &CModule1::set_switch_on, &CModule1::check_servo_on, &CModule1::end };
	fp move[4] = { &CModule1::set_position, &CModule1::set_point ,&CModule1::clear_set_point, &CModule1::end };
	fp stand_by[1] = {  &CModule1::end };
	fp stop[3] = { &CModule1::set_quick_stop,&CModule1::check_quick_stop_state ,&CModule1::end };
	fp fault_recover[4] = { &CModule1::set_disable_voltage, &CModule1::set_fault_reset, &CModule1::check_servo_off ,&CModule1::end };
	
	bool check_servo_on(Motor& motor)
	{
		if (motor.m_timeout_count > timeout_cnt) {
			execute = stand_by;
			motor.m_timeout_count = 0;
			return fail;
		}

		if ((m_Inputs.status_word[motor.m_num] & status_word::mask_type2) == status_word::operation_enabled) {
			motor.m_timeout_count = 0;
			return success;
		}
		else {
			motor.m_execute = motor.m_re_execute;
			motor.m_timeout_count++;
			return fail;
		}
	}

	bool check_servo_off(Motor& motor)
	{
		if (motor.m_timeout_count > timeout_cnt) {
			execute = stand_by;
			motor.m_timeout_count = 0;
			return fail;
		}

		if ((m_Inputs.status_word[motor.m_num] & status_word::mask_type1) == status_word::switch_on_disabled) {
			motor.m_timeout_count = 0;
			return success;
		}
		else {
			motor.m_execute = motor.m_re_execute;
			motor.m_timeout_count++;
			return fail;

		}
	}
	bool check_quick_stop_state(Motor& motor)
	{
		if (motor.m_timeout_count > timeout_cnt) {
			execute = stand_by;
			motor.m_timeout_count = 0;
			return fail;
		}

		if ((m_Inputs.status_word[motor.m_num] & status_word::mask_type2) == status_word::quick_stop_active) {
			motor.m_timeout_count = 0;
			return success;
		}
		else {
			motor.m_execute = motor.m_re_execute;
			motor.m_timeout_count++;
			return fail;
		}
	}

	//bool check_target_reached()
	//{
	//	/*for (auto motor = motors.begin(); motor != motors.end(); motor++) {
	//	if (check_status_word(USHORT target_reached)) {
	//	motor->UpdateCurrentPosition(m_DataArea3.target_position);
	//	}
	//	else {
	//	return fail;
	//	}
	//	}
	//	return success;*/

	//	//for (auto motor = motors.begin(); motor != motors.end(); motor++) {

	//	//	if ((m_Inputs.status_word & target_reached) != target_reached) {
	//	//m_DataArea3.state = state::standby; 
	//	//		return;
	//	//	}

	//	//
	//	//}
	//};

	//bool check_stopped()
	//{
	//	for (auto motor = motors.begin(); motor != motors.end(); motor++) {
	//		if ((m_Inputs.status_word & status_word::quick_stop_active) == status_word::quick_stop_active) {
	//			return fail;
	//		}
	//	}
	//	return success;
	//}

	//bool check_status() {
	//	for (auto motor = motors.begin(); motor != motors.end(); motor++) {
	//		//if ((m_Inputs.status_word & fault) == fault) {
	//		//transition 15
	//		m_Outputs.control_word = command::fault_reset;
	//		//}
	//	}
	//	return success;
	//}


	bool end(Motor& motor)
	{
		// always return false
		return false;
	}

	bool set_quick_stop(Motor& motor)
	{
		m_Outputs.control_word[motor.m_num] = command::quick_stop;
		return success;
	}

	bool set_position(Motor& motor)
	{
		m_Outputs.target[motor.m_num] = motor.GetTargetPosition(); //m_DataArea3.target_position;
		return success;
	}

	bool set_point(Motor& motor)
	{
		m_Outputs.control_word[motor.m_num] = command::switch_on_and_enable_oepration;
		return success;
	}

	bool clear_set_point(Motor& motor)
	{
		m_Outputs.control_word[motor.m_num] = command::enable_operation;
		return success;
	}

	bool set_disable_voltage(Motor& motor) {
		m_Outputs.control_word[motor.m_num] = command::disable_voltage;
		return success;
	}
	bool set_shutdown(Motor& motor) {
		m_Outputs.control_word[motor.m_num] = command::shutdown;
		return success;
	}

	bool set_switch_on(Motor& motor) {
		m_Outputs.control_word[motor.m_num] = command::enable_operation;
		return success;
	}
	bool set_ready_to_switch_on(Motor& motor) {
		m_Outputs.control_word[motor.m_num] = command::switch_on;
		return success;
	}
	bool set_fault_reset(Motor& motor) {
		m_Outputs.control_word[motor.m_num] = command::fault_reset;
		return success;
	}

};


