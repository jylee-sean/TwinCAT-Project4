///////////////////////////////////////////////////////////////////////////////
// Module1.h
#pragma once

#include "Untitled1Interfaces.h"
#include "AdsR0.h"
#include <vector>

//#include "Motor.h"
//#include <vector>


#define CALL_MEMBER_FN(object, ptrToMember) ((object).*(ptrToMember))
// parameter ids for TwinCAT module Module1 with disabled code generation
// could be moved to Untitled1Services.h
const PTCID PID_Module1AdsPort        = 0x00000002;








class CModule1 
	: public ITComObject
	, public ITcADI
	, public ITcWatchSource
///<AutoGeneratedContent id="InheritanceList">
	, public ITcCyclic
///</AutoGeneratedContent>
	, public CAdsR0FifoPort
	, public Motor

{
public:
	DECLARE_IUNKNOWN()
DECLARE_IPERSIST(CID_Untitled1CModule1)
DECLARE_ITCOMOBJECT_LOCKOP()
DECLARE_ITCADI()
DECLARE_ITCWATCHSOURCE()
DECLARE_OBJPARAWATCH_MAP()
DECLARE_OBJDATAAREA_MAP()



CModule1();
virtual	~CModule1();




///<AutoGeneratedContent id="InterfaceMembers">
	// ITcCyclic
virtual HRESULT TCOMAPI CycleUpdate(ITcTask* ipTask, ITcUnknown* ipCaller, ULONG_PTR context);

///</AutoGeneratedContent>

	// CAds
virtual	void	AdsReadWriteInd
(
	AmsAddr& rAddr,
	ULONG invokeId,
	ULONG indexGroup,
	ULONG indexOffset,
	ULONG cbReadLength,
	ULONG cbWriteLength,
	PVOID pData
);

virtual void AdsReadCon
(
	AmsAddr& rAddr,
	ULONG invokeId,
	ULONG result,
	ULONG cbLength,
	PVOID pData
);

enum RESULT {success = true, fail = false};

public:

protected:
	DECLARE_ITCOMOBJECT_SETSTATE();

	HRESULT AddModuleToCaller();
	VOID RemoveModuleFromCaller();
	
	// Tracing
	CTcTrace m_Trace;

	///<AutoGeneratedContent id="Members">
	TcTraceLevel m_TraceLevelMax;
	WORD m_DefaultAdsPort;
	WORD m_ContextAdsPort;
	ULONG m_Counter;
	SHORT m_move;
	LONG m_target;
	Module1Inputs m_Inputs;
	Module1Outputs m_Outputs;
	Module1DataArea3 m_DataArea3;

	ITcCyclicCallerInfoPtr m_spCyclicCaller;
	

	///</AutoGeneratedContent>

	void SubmitAdsReadReq();
	enum
	{
		invokeIdReadByOidAndPid = 1
	};
	ULONG  m_ReadByOidAndPid;
	
	std::vector<Motor> motors; // motors(10) ?? static ??

	static constexpr INT timeout_cnt =1000;



	fp* execute;
	fp* re_execute;

	//fp execute;
	//fp re_execute;

private:

	//std::vector<fp> servo_on = { &CModule1::set_disable_voltage };
	//	,&CModule1::set_shutdown, &CModule1::set_ready_to_switch_on, &CModule1::set_switch_on , &CModule1::end};
	
	fp servo_on[6] = { &CModule1::set_disable_voltage ,&CModule1::set_shutdown, &CModule1::set_ready_to_switch_on, &CModule1::set_switch_on, &CModule1::check_servo_on, &CModule1::end };
	fp move[4] = { &CModule1::set_position, &CModule1::set_point ,&CModule1::clear_set_point, &CModule1::end };
	fp stand_by[1] = {  &CModule1::end };
	fp stop[3] = { &CModule1::set_quick_stop,&CModule1::check_quick_stop_state ,&CModule1::end };
	fp fault_recover[4] = { &CModule1::set_disable_voltage, &CModule1::set_fault_reset, &CModule1::check_servo_off ,&CModule1::end };
	
	//std::array<fp,6> servo_on2 = { &CModule1::set_disable_voltage ,&CModule1::set_shutdown, &CModule1::set_ready_to_switch_on, &CModule1::set_switch_on, &CModule1::check_servo_on, &CModule1::end };
	//static bool check_stopped();

	bool check_servo_on()
	{
		static int cnt = 0;
		cnt++;

		if (cnt > timeout_cnt) {
			execute = stand_by;
			cnt = 0;
		}
		for (auto motor = motors.begin(); motor != motors.end(); motor++) {
			if ((m_Inputs.status_word & status_word::mask_type2) != status_word::operation_enabled) {
				execute = re_execute;
				return fail;
			}
		}
		cnt=0;
		return success; 
	}

	bool check_servo_off()
	{
		static int cnt = 0;
		cnt++;
		if (cnt > timeout_cnt) {
			execute = stand_by;
			cnt = 0;
		}

		for (auto motor = motors.begin(); motor != motors.end(); motor++) {
			if ((m_Inputs.status_word & status_word::mask_type1) != status_word::switch_on_disabled) {
				execute = re_execute;
				return fail;
			}
		}

		cnt = 0;
		return success;
	};
	bool check_quick_stop_state()
	{
		static int cnt = 0;
		cnt++;
		if (cnt > timeout_cnt) {
			execute = stand_by;
			cnt = 0;
		}

		for (auto motor = motors.begin(); motor != motors.end(); motor++) {
			if ((m_Inputs.status_word & status_word::mask_type2) != status_word::quick_stop_active) {
				execute = re_execute;
				return fail;
			}
		}

		cnt = 0;
		return success;
	};

	//bool check_target_reached()
	//{
	//	/*for (auto motor = motors.begin(); motor != motors.end(); motor++) {
	//	if (check_status_word(USHORT target_reached)) {
	//	motor->UpdateCurrentPosition(m_DataArea3.target_position);
	//	}
	//	else {
	//	return fail;
	//	}
	//	}
	//	return success;*/

	//	//for (auto motor = motors.begin(); motor != motors.end(); motor++) {

	//	//	if ((m_Inputs.status_word & target_reached) != target_reached) {
	//	//m_DataArea3.state = state::standby; 
	//	//		return;
	//	//	}

	//	//
	//	//}
	//};




	//bool check_stopped()
	//{
	//	for (auto motor = motors.begin(); motor != motors.end(); motor++) {
	//		if ((m_Inputs.status_word & status_word::quick_stop_active) == status_word::quick_stop_active) {
	//			return fail;
	//		}
	//	}
	//	return success;
	//}

	//bool check_status() {
	//	for (auto motor = motors.begin(); motor != motors.end(); motor++) {
	//		//if ((m_Inputs.status_word & fault) == fault) {
	//		//transition 15
	//		m_Outputs.control_word = command::fault_reset;
	//		//}
	//	}
	//	return success;
	//}


	bool end()
	{
		// always return false
		return false;
	}

	bool set_quick_stop()
	{
		for (auto motor = motors.begin(); motor != motors.end(); motor++) {
			m_Outputs.control_word = command::quick_stop;
		}
		return success;
	}

	bool set_position()
	{
		for (auto motor = motors.begin(); motor != motors.end(); motor++) {
			m_Outputs.target = motor->GetTargetPosition(); //m_DataArea3.target_position;
		}
		return success;
	}

	bool set_point()
	{
		for (auto motor = motors.begin(); motor != motors.end(); motor++) {
			m_Outputs.control_word = command::switch_on_and_enable_oepration;
		}
		return success;
	}

	bool clear_set_point()
	{
		for (auto motor = motors.begin(); motor != motors.end(); motor++) {
			m_Outputs.control_word = command::enable_operation;
		}
		return success;
	}
	
	bool set_disable_voltage() {
		for (auto motor = motors.begin(); motor != motors.end(); motor++) {
			m_Outputs.control_word = command::disable_voltage;
		}
		return success;
	}
	bool set_shutdown() {
		for (auto motor = motors.begin(); motor != motors.end(); motor++) {
			m_Outputs.control_word = command::shutdown;
		}
		return success;
	}

	bool set_switch_on() {
		for (auto motor = motors.begin(); motor != motors.end(); motor++) {
			m_Outputs.control_word = command::enable_operation;
		}
		return success;
	}
	bool set_ready_to_switch_on() {
		for (auto motor = motors.begin(); motor != motors.end(); motor++) {
			m_Outputs.control_word = command::switch_on;
		}
		return success;
	}
	bool set_fault_reset() {
		for (auto motor = motors.begin(); motor != motors.end(); motor++) {
			m_Outputs.control_word = command::fault_reset;
		}
		return success;
	}

};
